#!/bin/bash 

if [ -z "${BUILD_ROOT}" ]; then
    echo "You need to source buildenv first"
    exit 1
fi

function exit_on_error
{
    if [ $1 -ne 0 ]; then
        if [ -n "$2" ]; then
            echo "$2"
        fi
        exit $1
    fi
}

. ${BUILD_ROOT}/src/linux/build/common.sh
exit_on_error $?

. ${BUILD_ROOT}/src/linux/build/version.sh
exit_on_error $?

. ${BUILD_ROOT}/src/linux/build/lib/dep-helper.sh
exit_on_error $?

. ${BUILD_ROOT}/src/linux/build/lib/pkgtype-helper.sh
exit_on_error $?

. ${BUILD_ROOT}/src/linux/build/lib/installer-helper.sh
exit_on_error $?

# Build up the installer version string
INSTALLER_VER="${MAIN_VERSION}"
if [ -n "${OFFICIAL_BUILD_NUMBER}" ]; then
    INSTALLER_VER="${INSTALLER_VER}.${OFFICIAL_BUILD_NUMBER}"
fi

function setup_bitrock
{
    # The location of the bitrock installer
    if [ -z "${BUILD_BITROCK_ROOT}" ]; then
        # environment variable not defined, see if in standard location
        local v
        for v in 5.4.15 5.4.8 4.5.3 4.2.0 4.0.0 3.8.1; do
            if [ -d /opt/installbuilder-${v} ]; then
                BUILD_BITROCK_ROOT=/opt/installbuilder-${v}
                break;
            fi
        done
        if [ -z "${BUILD_BITROCK_ROOT}" ]; then
            echo "Could not find the location of BitRock InstallBuilder."
            echo "Please set the BUILD_BITROCK_ROOT environment variable"
            echo "to the location of BitRock InstallBuilder."
            exit 1
        fi
    fi

    echo "Using BitRock InstallBuilder in: ${BUILD_BITROCK_ROOT}"
}

function build_manifest
{
    local name="${1}"
    local manifest="${BUILD_META_OS_ROOT}/bitrock/${1}/MANIFEST"
    
    installer_build_manifest "${name}" "${manifest}"

    echo "${manifest}"
}

function make_bitrock
{
    local _os="$1"
    local _arch="$2"
    local _pkg_type="$3"
    local _platform="$4"
    local _compat="$5"
    local _install_dir="$6"
    local _staging_dir="$7"
    local _meta_dir="$8"
    local _out_dir="$9"
    local _pkg_name=`product_name ${PKG_CONFIG_NAME}`
    local _pkg_short_name="${_pkg_name}"
    local _pkg_full_name=`product_full_name ${PKG_CONFIG_NAME}`

    # pass some stuff in through environment variables
    export PACKAGEDIR="${_staging_dir}"

    # set up output file
    local PROCESSED_PROJECT_FILE="${_meta_dir}/bitrock.xml"
    local OUTPUT_DIRECTORY="${_out_dir}"
    local OUTPUT_FILENAME=${_pkg_name}-${INSTALLER_VER}-${_os}-${_arch}-${_pkg_type}-installer

    mkdir -p `dirname "${PROCESSED_PROJECT_FILE}"`
    exit_on_error $?

    local MANIFEST="`build_manifest ${PKG_CONFIG_NAME}`"

    # run sed on the project file to do some "early binding" on environment variables
    sed \
        -e s!\$\${BUILD_ROOT}!${BUILD_ROOT}! \
        -e s!\$\${MANIFEST}!${MANIFEST}! \
        -e s/\$\${PKGTYPE}/${_pkg_type}/ \
        -e s/\$\${ASKABOUT32BITLIBS}/${_compat}/ \
        -e s!\$\${INSTALLDIR}!${_install_dir}! \
        -e s!\$\${VERSION}!${INSTALLER_VER}! \
        -e s!\$\${OUTPUT_DIRECTORY}!${OUTPUT_DIRECTORY}! \
        -e s!\$\${OUTPUT_FILENAME}!${OUTPUT_FILENAME}! \
        -e s!\$\${SHORT_NAME}!${_pkg_short_name}! \
        -e s!\$\${FULL_NAME}!"${_pkg_full_name}"! \
        -e s!\$\${ALL_PRODUCTS_ROOT}!${BUILD_ROOT}/src/linux/build/products! \
        -e s!\$\${PRODUCT_ROOT}!${BUILD_ROOT}/src/linux/build/products/${PKG_CONFIG_NAME}! \
        -e s!\$\${BITROCK_ROOT}!${BUILD_ROOT}/src/linux/build/lib/bitrock! \
        < ${BUILD_ROOT}/src/linux/build/products/${PKG_CONFIG_NAME}/bitrock.xml > ${PROCESSED_PROJECT_FILE}

    # run the installer
    ${BUILD_BITROCK_ROOT}/bin/builder build "${PROCESSED_PROJECT_FILE}" "${_platform}"
    exit_on_error $?

    echo "Installer created at ${OUTPUT_DIRECTORY}/${OUTPUT_FILENAME}"
    echo ""

    # delete stuff from the staging area
    # clear_stage
}

function set_stage
{
    if [ -d "$1" ]; then
        rm -rf "$1"
    fi
    mkdir -p "$1"
    cp $2 "$1/."
}

function set_stage_compat
{
    set_stage "$1" "$2"

    # move any compatibility libs
    mkdir $1/compat
    mv $1/*32bit* "$1/compat/."
}

function get_compat_from_os_arch_pkg
{
    local _os="$1"
    local _arch="$2"
    local _pkg_type="$3"

    local _compat=""
    if [[ "${_os}" = 'linux' && "${_arch}" = 'x86_64' && "${_pkg_type}" = 'rpm' ]]; then
        _compat="yes"
    fi
    echo "${_compat}"
}

function get_platform_from_os_arch
{
    local _os="$1"
    local _arch="$2"

    local _platform=""
    case "${_os}" in
        linux)
            case "${_arch}" in
                i386)
                    _platform=linux
                    ;;
                x86_64)
                    _platform=linux-x64
                    ;;
                ppc)
                    _platform=linux-ppc
                    ;;
            esac
            ;;
        freebsd)
            case "${_arch}" in
                i386)
                    _platform=freebsd6
                    ;;
            esac
            ;;
        solaris)
            case "${_arch}" in
                sparc)
                    _platform=solaris-sparc
                    ;;
                i386)
                    _platform=solaris-intel
                    ;;
            esac
            ;;
	hpux)
            case "${_arch}" in
                hppa20)
                    _platform=hpux
                    ;;
                ia64)
                    _platform=hpux
                    ;;	    
	    esac
	    ;;
        aix)
            case "${_arch}" in
                powerpc)
                    _platform=aix
                    ;;
            esac
            ;;
    esac
    if [ -z "${_platform}" ]; then
        echo "Unknown OS/arch: ${_os} ${_arch}" 1>&2
        exit 1
    fi
    echo "${_platform}"
}

function make_wrap
{
    local _os="$1"
    local _arch="$2"
    local _pkg_type="$3"
    local _config="$4"
    local _platform="$5"
    local _spec="$6"
    local _prefix="${BUILD_PREFIX}"

    if [ "${_os}" = "aix" ]; then
	_prefix=/usr/lpp/likewise
    fi

    local _compat
    _compat=`get_compat_from_os_arch_pkg "${_os}" "${_arch}" "${_pkg_type}"`
    exit_on_error $?

    if [ -z "${_platform}" ]; then
        _platform=`get_platform_from_os_arch "${_os}" "${_arch}"`
        exit_on_error $?
    fi

    if [ -z "${_spec}" ]; then
        _spec=`product_packages_spec "${_os}" "${_arch}" "${_pkg_type}" "${_config}"`
        exit_on_error $?
    fi

    if [ -z "${_spec}" ]; then
        echo "Skipping $@"
        return 0
    fi

    local _meta_dir="${BUILD_META_OS_ROOT}/bitrock/${_config}/${_os}/${_arch}/${_pkg_type}"
    local _out_dir="${BUILD_DIST_ROOT}/${_os}/${_arch}/bitrock/${_config}"
    local _staging_dir="${_meta_dir}/packages"
    if [ "${_compat}" = "yes" ]; then
        set_stage_compat "${_staging_dir}/${_os}/${_arch}" "${_spec}"
    else
        _compat=no
        set_stage "${_staging_dir}/${_os}/${_arch}" "${_spec}"
    fi

    make_bitrock "${_os}" "${_arch}" "${_pkg_type}" "${_platform}" "${_compat}" "${_prefix}/setup/${_config}" "${_staging_dir}" "${_meta_dir}" "${_out_dir}"
}

function usage
{
    local _name=`basename $0`
    echo "usage: $_name [options] all"
    echo "   or: $_name [options] current"
    echo "   or: $_name --help"
    echo ""
    echo "    Create bitrock installers for as many products as possible."
    echo ""
    echo "  options:"
    echo ""
    echo "    --help - Shows this usage information."
    echo ""
    echo "  commands:"
    echo ""
    echo "    all                    Builds bitrock installers for all platforms."
    echo ""
    echo "    current                Builds bitrock installers for current platform."
    echo ""
    echo "    <os> <arch> <pkgType>  Builds bitrock installer for a particular target."
    echo "                           The supported targets include:"
    echo ""
    echo "      linux i386 rpm       (Linux, 32-bit RPMs)"
    echo "      linux x86_64 rpm     (Linux, 64-bit RPMs)"
    echo "      linux i386 deb       (Linux, 32-bit DEBs)"
    echo "      linux x86_64 deb     (Linux, 64-bit DEBs)"
    echo "      linux ppc rpm        (Linux, PowerPC RPMs)"
    echo "      solaris sparc pkg    (Solaris, Sparc PKGs)"
    echo "      aix powerpc rpm      (AIX, PowerPC RPMs)"
    echo ""
    echo "    <os> <arch> <pkgType> <platform> <fileSpec> <installDir>"
    echo "                           Builds bitrock installer with specific options:"
    echo ""
    echo "      <os>         see above."
    echo "      <arch>       see above."
    echo "      <pkgType>    see above."
    echo "      <platform>   is the bitrock target platform: linux, linux-x64,"
    echo "                    solaris-sparc, or aix."
    echo "      <fileSpec>   is the quoted pattern of files to include in the installer."
    echo "      <installDir> is the directory (on the target machine) to which bitrock"
    echo "                    should install"
    exit 1
}

function main
{
    setup_bitrock

    PKG_CONFIG_NAME=""
    parseOptDone=""

    while [ -z "$parseOptDone" ]; do
        case "$1" in
            --help)
                usage
                ;;
            *)
                parseOptDone=1
                ;;
        esac
    done

    if [ -z "$1" ]; then
        echo "Missing commands."
        usage
    fi

    if [ -n "${PKG_CONFIG_NAME}" ]; then
	PKG_CONFIG_LIST=`product_packages "${PKG_CONFIG_NAME}"`
	exit_on_error $? "Failed to get package config list."
    fi

    set_ctrlc_trap
    timer_start "Making bitrock installers"
    (
	## Save the original system BUILD_OS_TYPE so we can restore later 
	## if neccessary.  The mksfx.conf config file make decisions based 
	## on the platform
	local old_BUILD_OS_TYPE="${BUILD_OS_TYPE}"

        if [ "$#" = "0" ]; then
            echo "Missing commands."
            usage	    
        elif [ "$#" = "1" ]; then
            if [ "$1" = "all" ]; then
		for BUILD_OS_TYPE in linux freebsd solaris aix hpux; do
		    for BUILD_OS_ARCH in `pkgtype_get_current_os_arch_list`; do
			for PKG_TYPE in `pkgtype_get_current_os_pkgtype_allow_list`; do
			    for PKG_CONFIG_NAME in ${BUILD_PRODUCTS}; do
				make_wrap "${BUILD_OS_TYPE}" "${BUILD_OS_ARCH}" "${PKG_TYPE}" "${PKG_CONFIG_NAME}"
			    done
			done
		    done
		done
            elif [ "$1" = "current" ]; then
		for PKG_CONFIG_NAME in ${BUILD_PRODUCTS}; do
		    for PKG_TYPE in `pkgtype_get_current_os_pkgtype_list` ; do
			make_wrap "${BUILD_OS_TYPE}" "${BUILD_OS_ARCH}" "${PKG_TYPE}" "${PKG_CONFIG_NAME}"
		    done
		done
            else
                echo "Invalid command: '$1'."
                usage
            fi
        else
            echo "Too many commands."
            usage
        fi
        exit_on_error $?
	BUILD_OS_TYPE="${old_BUILD_OS_TYPE}"
    )
    rc=$?
    timer_stop
    exit_on_error $rc
}

main "$@"
exit $?
