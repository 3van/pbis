#!/usr/bin/ksh
#**********************************************************************
#                                                                     *
# LPPBUILD_MAP_FILES                                                  *
#                                                                     *
# This procedure is called to create a set of directories in the      *
# lppbuild work directory which exactly map the originals in the      *
# user's product directory and which contain hard links back to the   *
# original files.                                                     *
#                                                                     *
# As this duplicate "skeleton" is built, those files which should     *
# actually be located in the inst_root area of the distribution are   *
# created there, ready for the building of the slightly different     *
# lpp file structure needed for the root part of an install or        *
# update component.                                                   *
#                                                                     *
# Incoming parameters are as follows:                                 *
#                                                                     *
# $1 - The name of the product                                        *
# $2 - The name of the component                                      *
# $3 - The name of the directory to receive user files                *
# $4 - The name of the directory to receive root files                *
#                                                                     *
# This routine will create a root structure in the work directory     *
# and link all the files in the source directory across, checking     *
# for duplicates within the product as a whole. The current directory *
# is assumed to be the product directory we are working in.           *
#                                                                     *
#**********************************************************************

binlib=`dirname $0`                       # access source directory
restore=`pwd`                             # save current directory
product=$1                                # names easier to work with
component=$2                              # names easier to work with
instuser=$3                               # target for user files
instroot=$4                               # target for root files

#**********************************************************************
#                                                                     *
# INTERNAL PROCEDURE                                                  *
#                                                                     *
# getmode will return the octal version of the permissions for the    *
# incoming filename, including suid, guid, etc.                       *
#                                                                     *
#**********************************************************************

getmode()
{
 ls -ld $1 | awk \
 '{j=256                                   # highest "bit" value
   for(i=2;i<11;i++)                       # take 2nd-10th char of perms
    {                                      # and process each one
     if (substr($1,i,1)!~/[-ST]/)          # "-" "S" and "T" all mean "off"
       mode+=j                             # take decimal equivalent if "on"
     j/=2                                  # get decimal equivalent of next
    }                                      # end of basic permissions
   if (substr($1,4,1)~/[Ss]/)              # setuid is on?
     mode+=2048                            # so add the 4000 bit
   if (substr($1,7,1)~/[Ss]/)              # Guid is on?
     mode+=1024                            # so add the 2000 bit
   if (substr($1,10,1)~/[Tt]/)             # link permisssion on?
     mode+=512                             # so add the 1000 bit
   printf("%o\n", mode)                    # display the octal permissions
 }'                                        # end of awk script
}                                          # end of function

#**********************************************************************
#                                                                     *
# First process all the user files and create directories to match    *
# the originals in the given target directory.                        *
#                                                                     *
#**********************************************************************

echo Processing files for $component...   # progress indicator
cd $component/root                        # switch to component directory
for dir in `find . -type d -print | grep "./usr"`; do
  outdir=$instuser${dir#\.}               # add base and remove leading "."
  if [ ! -d $outdir ]; then               # does it exist yet?
    mkdir -p $outdir                      # if not, then it does now
    owner=`ls -ld $dir | awk '{printf("%s.%s",$3,$4)}'` # who owns it then?
    perms=`getmode $dir`                  # and what are its permissions?
    chown $owner $outdir                  # assigned required ownership
    chmod $perms $outdir                  # assigned required permissions
  fi                                      # end of directory create
done                                      # end of directory scan

#**********************************************************************
#                                                                     *
# Now examine all the files and make hard links back to the original  *
# source files.                                                       *
#                                                                     *
#**********************************************************************

for file in `find . \( ! -type d -a ! -type l \) -print | grep "./usr"`; do
  outfile=$instuser${file#\.}             # add base and remove leading "."
  if [ -f $outfile ]; then                # does it already exist?
    echo LPPBUILD - ERROR duplicate file \"$file\" found processing \"$product.$component\"
    exit -1                               # retreat into oblivion
  fi                                      # end of error reporting
  ln $file $outfile                       # otherwise create a link
done                                      # end of file scan

#**********************************************************************
#                                                                     *
# Finally look for symbolic links and attempt to recreate them in the *
# lppgen directory.                                                   *
#                                                                     *
#**********************************************************************

for file in `find . -type l -print | grep "./usr"`; do
  outfile=$instuser${file#\.}             # add base and remove leading "."
  if [ -f $outfile ]; then                # does it already exist?
    echo LPPBUILD - ERROR duplicate link \"$file\" found processing \"$product.$component\"
    exit -1                               # retreat into oblivion
  fi                                      # end of error reporting
  target=`ls -l $file | awk '{print $11}'` # find out where it goes
  ln -s $target $outfile                  # and replicate this link
done                                      # end of file scan

#**********************************************************************
#                                                                     *
# Repeat the above processing but now only process files which are    *
# in the root part of the product and make the copies in the given    *
# root target directory.                                              *
#                                                                     *
#**********************************************************************

for dir in `find . -type d -print | grep -v "./usr" | grep -x -v "."`; do
  outdir=$instroot${dir#\.}               # add base and remove leading "."
  if [ ! -d $outdir ]; then               # does it exist yet?
    mkdir -p $outdir                      # if not, then it does now
    owner=`ls -ld $dir | awk '{printf("%s.%s",$3,$4)}'` # who owns it then?
    perms=`getmode $dir`                  # and what are its permissions?
    chown $owner $outdir                  # assigned required ownership
    chmod $perms $outdir                  # assigned required permissions
  fi                                      # end of directory create
done                                      # end of directory scan

#**********************************************************************
#                                                                     *
# Now examine all the files and make hard links back to the original  *
# source files.                                                       *
#                                                                     *
#**********************************************************************

for file in `find . \( ! -type d -a ! -type l \) -print | grep -v "./usr"`; do
  outfile=$instroot${file#\.}             # add base and remove leading "."
  if [ -f $outfile ]; then                # does it already exist?
    echo LPPBUILD - ERROR duplicate file \"$file\" found processing \"$product.$component\"
    exit -1                               # retreat into oblivion
  fi                                      # end of error reporting
  ln $file $outfile                       # otherwise create a link
done                                      # end of file scan

#**********************************************************************
#                                                                     *
# Finally look for symbolic links and attempt to recreate them in the *
# lppgen directory.                                                   *
#                                                                     *
#**********************************************************************

for file in `find . -type l -print | grep -v "./usr"`; do
  outfile=$instroot${file#\.}             # add base and remove leading "."
  if [ -f $outfile ]; then                # does it already exist?
    echo LPPBUILD - ERROR duplicate link \"$file\" found processing \"$product.$component\"
    exit -1                               # retreat into oblivion
  fi                                      # end of error reporting
  target=`ls -l $file | awk '{print $11}'` # find out where it goes
  ln -s $target $outfile                  # and repliccate this link
done                                      # end of file scan
cd $restore                               # go back to where we were

