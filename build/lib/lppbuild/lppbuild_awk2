#******************************************************************************
#                                                                             *
# LPPBUILD_AWK2                                                               *
#                                                                             *
# This awk script is used to process the working list of components and       *
# will use them to build a suitable lpp_name file. This file details the      *
# contents of the package and indicates to installp what type of LPP they     *
# are.                                                                        *
#                                                                             *
# Note that installp cannot mix original installations with updates or        *
# share only with root/usr lpps, so we will have to separate these all        *
# out from each other and bitch if they have been mixed in the same product.  *
#                                                                             *
# The records into this script come from a file built with data from the      *
# component control files by lppbuild_awk1 and have the following fields:     *
#                                                                             *
# $1  - The product name                                                      *
# $2  - The component name                                                    *
# $3  - The version in IBM vv.rr.mm.ff format                                 *
# $4  - The type as U, B or H for user only, user and root, or share          *
# $5  - A string which is the description of the component                    *
# $6  - A value for the bosboot option in lpp_name                            *
# $7  - A value for the PAGESPACE size requirements                           *
# $8  - A value for the INSTWORK size requirements                            *
# $9  - A string which is the fix identifier                                  *
# $10 - A value for the user SAVESPACE value                                  *
# $11 - A value for the root SAVESPACE value                                  *
#                                                                             *
# This script expects a value for the "target" variable to be passed in as    *
# the name of the directory within which the lpp_name file should be built.   *
#                                                                             *
# The records are read and their details stored in arrays. The END function   *
# then converts the arrays into data for the lpp_name file.                   *
#                                                                             *
#******************************************************************************
#******************************************************************************
#                                                                             *
# Begin procedure. Initialize various work fields and counters                *
# AWK will actually initialize these at first use, but what the hell..        *
#                                                                             *
#******************************************************************************

BEGIN { FS=":"                         # caller will use colon separator
 mainidx=0                             # main index to arrays
 mixinstalls=0                         # count of user/root installs in package
 mixupdates=0                          # count of user/root updates in package
 shrinstalls=0                         # count of share installs in package
 shrupdates=0                          # count of share updates in package
 error=0                               # internal logic flag
}

#******************************************************************************
#                                                                             *
# Main processing start. Read in each record and store the details in arrays  *
# until we have them all. Split the version number into bits using the        *
# periods as delimiters.                                                      *
#                                                                             *
#******************************************************************************

{
 product[mainidx]=$1                   # pick up the details
 component[mainidx]=$2                 # pick up the details
 version[mainidx]=$3                   # pick up the details
 lpptype[mainidx]=$4                   # pick up the details
 descr[mainidx]=$5                     # pick up the details
 bosboot[mainidx]=$6                   # pick up the details
 pagespace[mainidx]=$7                 # pick up the details
 instwork[mainidx]=$8                  # pick up the details
 fixinfo[mainidx]=$9                   # pick up the details
 usersave[mainidx]=$10                 # pick up the details
 rootsave[mainidx]=$11                 # pick up the details

#******************************************************************************
#                                                                             *
# If either the modification level or the fix level are non-zero, then this   *
# is probably an update level, otherwise it is an original installation.      *
# The IBM documentation implies that this logic can be overridden within the  *
# prerequisite/corequisite/supersede specifications of the package. We are    *
# ignoring this possibility for the moment.                                   *
#                                                                             *
#******************************************************************************

 work=split($3,vbits,".");             # break up the version
 if (work!=4)                          # we should have 4 parts
  {                                    # otherwise this lpp is shot to hell
   printf("LPPBUILD - ERROR, bad version (\"%s\") in control file for \"%s.%s\"\n",
   $3,$1,$2);                          # tell the user about this
   error=1;                            # signal we had a problem
   exit -1;                            # stop reading this crap
  }                                    # end of version testing
 if (vbits[3] != 0 || vbits[4] != 0)   # implied update part?
   lppmode[mainidx]="U";               # set indicator of our opinion
 else                                  # otherwise they are both zero
   lppmode[mainidx]="I";               # so it must be an install part

#******************************************************************************
#                                                                             *
# We have a mode, which indicates either an install or an update, and we also *
# have the lpptype, which distinguishes between a user part (U), a root+user  *
# part (B) or a share part (H). In general, we can mix U with B but neither   *
# with H. We also cannot mix modes (Install or Update) whatever the types.    *
#                                                                             *
# The following will concatenate the type and the mode and then count the     *
# various combinations for legitimacy checking later.                         *
#                                                                             *
#******************************************************************************

 work=lpptype[mainidx] lppmode[mainidx] # concatenate type and mode
 if      (work == "UI")                # user only install
   mixinstalls+=1                      # count them up
 else if (work == "BI")                # user+root install
   mixinstalls+=1                      # count them up
 else if (work == "UU")                # user only update
   mixupdates+=1                       # count them up
 else if (work == "BU")                # user+root update
   mixupdates+=1                       # count them up
 else if (work == "HI")                # share install
   shrinstalls+=1                      # count them up
 else if (work == "HU")                # share update
   shrupdates+=1                       # count them up
 else                                  # otherwise something went wrong
  {                                    # so this is parrot is dead
   printf("LPPBUILD - ERROR, internal logic error processing \"%s.%s\"\n",
   $1,$2);                             # tell the user about this
   error=1;                            # signal we had a problem
   exit -1;                            # stop reading this crap
  }                                    # end of error reporting

#******************************************************************************
#                                                                             *
# increment the array index and quit the procedure to go round again for the  *
# next record.                                                                *
#                                                                             *
#******************************************************************************

 mainidx+=1                            # next entry in array
}

#******************************************************************************
#                                                                             *
# END processing. We now know how many of each possible type of lpp we have   *
# and can use this to punch out a suitable lpp_name file.                     *
#                                                                             *
# The first thing we need to do here is see if the user has mixed installs    *
# with updates and/or root/root+usr parts with share parts. Issue an error    *
# message if so and bring things to a halt.                                   *
#                                                                             *
#******************************************************************************

END {
 if (error) exit -1;                   # bypass if earlier problems
 total=mixinstalls+mixupdates+shrinstalls+shrupdates # have this many components
 if ((mixinstalls != 0 && mixinstalls != total) \
   ||(mixupdates  != 0 && mixupdates  != total) \
   ||(shrinstalls != 0 && shrinstalls != total) \
   ||(shrupdates  != 0 && shrupdates  != total))
   {                                   # I knew it, he blew it
    print "LPPBUILD - ERROR, You have an inadmissible combination of components"
    print "           in the current product directory. Either there are both  "
    print "           install and update type lpp\'s, or there are both share  "
    print "           parts and root or root+user parts of an lpp.             "
    print "                                                                    "
    print "           Please separate out all install and update lpp\'s into   "
    print "           separate products and also ensure that share parts are   "
    print "           in separate products from root or root+user parts.       "
    print "                                                                    "
    print "           Generally, root+user parts contain files in /etc, /dev,  "
    print "           /sbin or /var, whereas user parts do not. Share parts    "
    print "           contain files exclusively in /usr/share.                 "
    print "                                                                    "
    print "           Update parts are those in which either of the last two   "
    print "           numbers of the version is non-zero. In other words,      "
    print "           1.0.0.0 or 1.1.0.0 are installs whereas 1.0.0.1 or       "
    print "           1.0.1.0 are assumed to be updates.                       "
    print "                                                                    "
    print "                                                                    "
    exit -1;                           # force a precipitate stop
   }                                   # end of consistency checking

#******************************************************************************
#                                                                             *
# Theoretically we now have everything we need to build the package and it all*
# appears at least superficially consistent and valid. Preprocess the data    *
# a little and establish some values for the lpp_name file.                   *
#                                                                             *
#******************************************************************************

 lppname=target "/lpp_name";              # generate output file name
 if (mixinstalls > 0 || shrinstalls > 0)  # is this an install package?
   ptype="I";                             # if so, identify it as such
 else                                     # otherwise not an install
   if (mixupdates > 1 || shrupdates > 1)  # more than 1 update included
     ptype="ML";                          # then it is maintenance level
   else                                   # otherwise just a single update
     ptype="S";                           # so signify this

#******************************************************************************
#                                                                             *
# Create the lpp_name header, which identifies the package type and gives it  *
# a name. We open curly braces so that details specific to each component     *
# can then be added to the end of this data.                                  *
#                                                                             *
#******************************************************************************

 printf("4 R %s %s {\n",ptype,product[0]) >lppname; # create lpp_name header

#******************************************************************************
#                                                                             *
# Now we can build the rest of the lpp_name file by component. For each such  *
# component we must create a record containing various parameters such as     *
# its actual name and version number. This information is then followed by    *
# a number of additional sections of information separated by percent signs.  *
#                                                                             *
# We can create the first record of this set and the required size information*
# automatically but cannot determine the prerequisites or any supersede data. *
# These latter are optional. If the component directory contains files called *
# "requisites" or "supersede", then the data from these files will be copied  *
# into the correct place in the lpp_name file. If not, these fields will be   *
# left empty.                                                                 *
#                                                                             *
# There are also a number of optional values which originate in the control   *
# file and which will have been passed in here. Store them appropriately      *
# in the lpp_name as we go through each component.                            *
#                                                                             *
# First get the optional requisite/supersede file names and setup the basic   *
# control record for each component in turn.                                  *
#                                                                             *
#******************************************************************************

 for (i=0;i<mainidx;i++)               # for each component in the product
  {                                    # update lpp_name and create files
   reqsfile=component[i] "/requisites";  # contains requisites information
   superfile=component[i] "/supersede";  # contains supersede information
   printf("%s.%s %s 1 %s %s en_US %s\n",
   product[i],component[i],version[i],bosboot[i],lpptype[i],descr[i]) >>lppname

#******************************************************************************
#                                                                             *
# Start the additional information field (identified by square brackets) and  *
# copy the requisites file (if any) before writing the field separator (%).   *
#                                                                             *
#******************************************************************************

   printf("[\n") >>lppname;            # start detailed information
   while (getline < reqsfile > 0)      # read any requisite information
     print $0 >>lppname;               # add this to control data
   printf("%\n") >>lppname;            # delimit any requisite data

#******************************************************************************
#                                                                             *
# Call lppbuild_make_sizes to create the mandatory directory size values and  *
# then test for optional user values for PAGESPACE and INSTWORK. If they have *
# been specified, add them to the size field.                                 *
#                                                                             *
#******************************************************************************

   close(lppname);                     # needed for following to work:
   system("lppbuild_make_sizes " component[i] "/root>>" lppname);
   if (pagespace[i] != "")             # did he provide on of these
     print "PAGESPACE " pagespace[i] >>lppname # if so, add to size file
   if (instwork[i] != "")              # did he provide on of these
     print "INSTWORK " instwork[i] >>lppname # if so, add to size file

#******************************************************************************
#                                                                             *
# If this is an update component, the user may have specifed sizes for the    *
# disk space needed to save old files. test for these and add the sizes to the*
# end of the information we have already built.                               *
#                                                                             *
#******************************************************************************

   if (lppmode[i] == "U")              # do we have an update package
    {                                  # if so, SAVESPACE is relevant
     if (rootsave[i] != "" && lpptype[i] == "B")     # root save is relevant
       print "/lpp/SAVESPACE " rootsave[i] >>lppname # if so, add to size file
     if (usersave[i] != "")            # he specified user/share save space
      {                                # they are different in fact
       if (lpptype[i] == "H")          # is this share part
         print "/usr/share/lpp/SAVESPACE " usersave[i] >>lppname # if so, add
       else                            # otherwise it is root/user
         print "/usr/lpp/SAVESPACE " usersave[i] >>lppname # so add that
      }                                # end of user or share savespace
    }                                  # end if update package specials
   printf("%\n") >>lppname;            # delimit the size information

#******************************************************************************
#                                                                             *
# If user has a supersede file, add it to the lpp_name file                   *
#                                                                             *
#******************************************************************************

   while (getline < superfile > 0)     # read any supersede information
     print $0 >>lppname;               # add this to control data

#******************************************************************************
#                                                                             *
# If this is an update component, then the user could have specified some     *
# fix information. Handle it if so.                                           *
#                                                                             *
#******************************************************************************

   if (lppmode[i] == "U")              # do we have an update package
    {                                  # if so, FIXINFO is relevant
     if (fixinfo[i] != "")             # did he in fact code a fixinfo?
      {                                # if so, we should copy it
       printf("%\n") >>lppname;        # delimit the last section
       print fixinfo[i] >>lppname      # and then install our new section
      }                                # end of storeing fixinfo
    }                                  # end of handling fixinfo

#******************************************************************************
#                                                                             *
# Phew. Close off the detail section for the current component and then end   *
# the loop which will iterate through all components. When this ends, close   *
# the whole set of information with a right brace.                            *
#                                                                             *
#******************************************************************************

   printf("]\n") >>lppname;            # end detailed information
  }                                    # end of individual processing
 printf("}\n") >>lppname               # close off the lpp_name file

#******************************************************************************
#                                                                             *
# We are now going to create a copy of the file structure for each component  *
# and create links from within it back to the original files in the component *
# directory. We do this because those files which constitute the root part of *
# the component are stored in a different place to the rest of the files.     *
#                                                                             *
# There are also differences in the final location of the control file library*
# known as "liblpp.a". This library contains certain control information as   *
# well as optional user scripts to be invoked at different stages of install  *
# processing. First sort out where things should go.                          *
#                                                                             *
#******************************************************************************

 for (i=0;i<mainidx;i++)               # run the tables again
  {                                    # determine suitable path names
   if (mixinstalls > 0)                # is this an ordinary install
    {                                  # which is the simplest case
     userlpp=target "/usr/lpp/" product[i];              # liblpp.a goes here
     rootlpp=target "/usr/lpp/" product[i] "/inst_root"; # root liblpp.a goes here
    }                                  # end of ordinary installs
   else if (shrinstalls > 0)           # or are we installing shared parts
    {                                  # which is the simplest share case
     userlpp=target "/usr/share/lpp/" product[i]; # liblpp.a goes here
     rootlpp=target "/usr/share/lpp/" product[i]; # is no root for share, really
    }                                  # end of share installs
   else if (mixupdates > 0)            # or are we updating products
    {                                  # which implies a different name structure
     userlpp=target "/usr/lpp/" product[i] "/" product[i] "." component[i] "/" version[i];
     rootlpp=target "/usr/lpp/" product[i] "/" product[i] "." component[i] "/" version[i] "/inst_root";
    }                                  # end of product updates
   else                                # must be shrupdates > 0 then
    {                                  # which also has its own name structure
     userlpp=target "/usr/share/lpp/" product[i] "/" product[i] "." component[i] "/" version[i];
     rootlpp=target "/usr/share/lpp/" product[i] "/" product[i] "." component[i] "/" version[i];
    }                                  # end of ordinary installs

#******************************************************************************
#                                                                             *
# Now we can massage the files into the required shape. Lppbuild_map_files    *
# will create a replica of the user's directory structure with hard links     *
# back to the original files. Lppbuild_user_lib will collect all the files    *
# and control information which should go into liblpp.a and then build it.    *
# Lppbuild_root_lib does the same job but for the root part of those products *
# which are root+user.                                                        *
#                                                                             *
# The shell scripts will return non-zero values if they detect any sort of    *
# an error. We can assume that they will already have issued some kind of     *
# error message.                                                              *
#                                                                             *
#******************************************************************************

   if (system("lppbuild_map_files " product[i] " " component[i] " " target " " rootlpp))
     exit -1;                          # stop if we had an error
   if (lpptype[i] == "B")              # does this guy have a root part?
     if (system("lppbuild_root_lib " product[i] " " component[i] " " rootlpp))
       exit -1;                        # stop if we had an error
   if (system("lppbuild_user_lib " product[i] " " component[i] " " userlpp " " target))
     exit -1;                          # stop if we had an error
  }                                    # end of individual processing
}                                      # end of the script

