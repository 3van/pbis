#!/bin/bash

source "${BUILD_ROOT}/src/linux/build/lib/pkgtype-helper.sh"
source "${BUILD_ROOT}/src/linux/build/lib/dep-helper.sh"
source "${BUILD_ROOT}/src/linux/build/lib/depot-helper.sh"
source "${BUILD_ROOT}/src/linux/build/lib/zip-helper.sh"

function safe_rmtree
{
    if [ -z "$1" ]; then
        echo "No directory tree name to remove"
        exit 1
    fi
    if [ "$1" != "/" ]; then
        if [ -d "$1" ]; then
            rm -rf "$1"
            exit_on_error $?
        fi
    fi
}

function recreate_dir
{
    safe_rmtree "$1"
    mkdir -p "$1"
    exit_on_error $?
}


function copy_dist
{
    check_arg "label" "$1"
    check_arg "path" "$2"

    echo "Copying $1 ${PKG_TYPE} to dist at ${PKG_DIST_DIR}"/`basename "$2"`

    cp -pr $2 ${PKG_DIST_DIR}/.
    exit_on_error $?

    if [ -n "$3" ]; then
        cp -p $3 ${PKG_DIST_DIR}/.
        exit_on_error $?
    fi
}

function rpm_get_compat_name
{
    local suffix=""

    if [ -n "$1" ]; then
        suffix=-32bit
    fi

    echo "${PKG_NAME}${suffix}"
}

function _rpm_extract
{
    check_arg "extract_dir" "$1"
    check_arg "rpm_path" "$2"

    echo "Extracting $2 to $1"
    (cd $1 && (rpm2cpio $2 | cpio -id))
    exit_on_error $?
}

function _rpm_query
{
    local query="$1"
    local file="$2"

    #
    # Determine whether platform support --nosignature option
    #

    local RPM_NOSIGNATURE=`get_rpm_nosignature_option`
    local result=`rpm ${RPM_NOSIGNATURE} -q --qf "${query}" -p ${file}`
    exit_on_error $?

    #
    # If an invalid file happens, we do not get anything, but $? is
    # not set.
    #

    if [ -z "$result" ]; then
        return 1
    fi

    echo "$result"
    return 0
}

function rpm_check_dir_type
{
    local _type="$1"

    local _dir="${PKG_PACKAGE_ROOT}/${_type}"
    local _rpm
    eval _rpm="\$_RPM_${_type}_DIR"

    if [ "${_rpm}" != "${_dir}" ]; then
        echo "Unexpected ${_type} dir: ${_rpm}"
        exit 1
    fi
}

function package_deb
{
    package_init
    populate "${PKG_PREFIX_DIR}" ""

    mkdir -p ${PKG_PACKAGE_ROOT}/${PKG_NAME}/debian
    for file in ${PKG_DIR}/{control,rules,changelog,*.install}; do
        file="`basename "$file"`"
        cat ${PKG_DIR}/$file | sed -e "s/__PKG_NAME/${PKG_NAME}/g" \
            -e "s/__PKG_VERSION/${PKG_VERSION}/g" \
	    -e "s:__PKG_PREFIX:${BUILD_PREFIX}:g" \
        > ${PKG_PACKAGE_ROOT}/${PKG_NAME}/debian/$file
    done

    if [ -n "${BUILD_DEBUG}" ]; then

       local rules_file=${PKG_PACKAGE_ROOT}/${PKG_NAME}/debian/rules
       local tmp_rules_file=$rules_file.no_dhstrip

       sed "s/dh_strip//g" $rules_file > $tmp_rules_file

       mv $tmp_rules_file $rules_file
       exit_on_error $?

    fi

    chmod 755 ${PKG_PACKAGE_ROOT}/${PKG_NAME}/debian/rules

    echo "Building ${PKG_NAME} ${PKG_TYPE}..."
    (cd ${PKG_PACKAGE_ROOT}/${PKG_NAME} && \
        dpkg-buildpackage -a`pkgtype_convert_pkgtype_and_arch_to_larch deb $BUILD_OS_ARCH` -rfakeroot -uc -b)
    exit_on_error $?

    fullPath="${PKG_PACKAGE_ROOT}/${PKG_NAME}*.deb"

    copy_dist "${PKG_NAME}" "${fullPath}"
}

function package_rpm
{
    package_init
    populate "${PKG_PREFIX_DIR}" ""

    local RPM_DEFINE_TOPDIR="--define=_topdir ${PKG_PACKAGE_ROOT}"

    local _RPM_SOURCES_DIR=`rpm "${RPM_DEFINE_TOPDIR}" --eval %_sourcedir`
    local _RPM_SPECS_DIR=`rpm "${RPM_DEFINE_TOPDIR}" --eval %_specdir`
    local _RPM_BUILD_DIR=`rpm "${RPM_DEFINE_TOPDIR}" --eval %_builddir`
    local _RPM_SRPMS_DIR=`rpm "${RPM_DEFINE_TOPDIR}" --eval %_srcrpmdir`
    local _RPM_RPMS_DIR=`rpm "${RPM_DEFINE_TOPDIR}" --eval %_rpmdir`

    local _RPM_BUILDROOT_DIR="${PKG_PACKAGE_ROOT}/buildroot"

    rpm_check_dir_type SOURCES
    rpm_check_dir_type SPECS
    rpm_check_dir_type BUILD
    rpm_check_dir_type SRPMS
    rpm_check_dir_type RPMS

    mkdir -p ${PKG_PACKAGE_ROOT}/{SOURCES,SPECS,BUILD,SRPMS,RPMS,buildroot}

    local origSpecFile="${PKG_DIR}/${PKG_ALIAS}.spec"
    local specFile="${_RPM_SPECS_DIR}/${PKG_ALIAS}.spec"

    if [ -f "${PKG_DIR}/macros.m4" ]; then
        m4 "${PKG_DIR}/macros.m4" "${origSpecFile}" > "${specFile}"
    else
        cp "${origSpecFile}" "${specFile}"
    fi
    exit_on_error $?

    local rpmName=`rpm_get_compat_name ${PKG_IS_COMPAT}`
    local RPMBUILD="rpmbuild"
    local RPM_DEFINE_AIX=--define='AIX 0'
    local RPM_DEFINE_COMPAT=--define='Compat32 0'
    local OLDLIBC=0
    if check_is_rhel_21; then
        OLDLIBC=1
    fi

    if [ "${BUILD_OS_TYPE}" = 'aix' ]; then
        RPMBUILD="rpm"
        RPM_DEFINE_AIX=--define='AIX 1'
    fi

    if [ -n "${PKG_IS_COMPAT}" ]; then
        RPM_DEFINE_COMPAT=--define='Compat32 1'
    fi

    # Workaround for RPM stripping files
    local pathOverride="${PATH}"
    if [ -n "${BUILD_DEBUG}" ]; then
        mkdir -p "${PKG_PACKAGE_ROOT}/path"
        exit_on_error $?
        cat <<EOF > "${PKG_PACKAGE_ROOT}/path/strip"
#!/bin/sh
echo 'SKIP: strip '"\$@"
EOF
        exit_on_error $?
        chmod a+x "${PKG_PACKAGE_ROOT}/path/strip"
        exit_on_error $?
        pathOverride="${PKG_PACKAGE_ROOT}/path:${PATH}"
    fi

    echo "Building ${rpmName} ${PKG_TYPE}..."
    PATH="${pathOverride}" \
        ${RPMBUILD} \
        "--target=${_RPM_BUILD_OS_ARCH}" \
        \
        "${RPM_DEFINE_TOPDIR}" \
        '--define=_rpmfilename %%{ARCH}/%%{NAME}-%%{VERSION}-%%{RELEASE}.%%{ARCH}.rpm' \
        \
        "--define=RpmName ${rpmName}" \
        "--define=RpmVersion ${PKG_VERSION}" \
        "--define=RpmRelease ${PKG_FULL_RELEASE}" \
        \
        "--define=buildRootDir ${_RPM_BUILDROOT_DIR}" \
        \
        "--define=PrefixDir ${PKG_PREFIX_DIR}" \
        "--define=StagingPrefix ${COMP_STAGING_PREFIX}" \
        "--define=StagingSuffix ${COMP_STAGING_SUFFIX}" \
        "--define=PopulateRoot ${PKG_POPULATE_ROOT}" \
        "--define=OldLibC ${OLDLIBC}" \
        "--define=LikewisePkgDesc ${PKG_DESC}" \
        \
        "${RPM_DEFINE_COMPAT}" \
        "${RPM_DEFINE_AIX}" \
        \
        -bb "${specFile}"
    exit_on_error $?

    local fullPath="${_RPM_RPMS_DIR}/${_RPM_BUILD_OS_ARCH}/${rpmName}-${PKG_VERSION}-${PKG_FULL_RELEASE}.${_RPM_BUILD_OS_ARCH}.rpm"
    #mkdir -p "${PKG_EXPAND_ROOT}"
    #_rpm_extract "${PKG_EXPAND_ROOT}" "${fullPath}"

    local compatSuffix=""
    if [ -n "${COMP_IS_COMPAT}" ]; then
        compatSuffix=" (compat)"
    fi
    copy_dist "${PKG_NAME}${compatSuffix}" "${fullPath}"
}

function package_depot
{
    package_init
    populate "${PKG_PREFIX_DIR}" ""

    local _TAR_FILE=${PKG_PACKAGE_ROOT}/${PKG_NAME}-${PKG_VERSION}.${PKG_RELEASE}-${BUILD_OS_ARCH}-staging.tar.bz2
    local _PKG_FILE=${PKG_PACKAGE_ROOT}/${PKG_NAME}-${PKG_VERSION}.${PKG_RELEASE}-${BUILD_OS_ARCH}.depot

    rsync -a --exclude .svn ${PKG_DIR}/ ${PKG_PACKAGE_ROOT}/
    exit_on_error $?
    
    ln -s ${PKG_POPULATE_ROOT} ${PKG_PACKAGE_ROOT}/root
    exit_on_error $?
    
    ln -s ${PKG_POPULATE_ROOT}/${PKG_PREFIX_DIR} ${PKG_PACKAGE_ROOT}/prefix
    exit_on_error $?

    depot_generate_psf "${PKG_ALIAS}" "${PKG_PACKAGE_ROOT}/pkg.psf"

    pushd ${PKG_PACKAGE_ROOT}
    /usr/sbin/swpackage -d ${_PKG_FILE} -x target_type=tape -s  ${PKG_PACKAGE_ROOT}/pkg.psf
    exit_on_error $?
    popd
    
    copy_dist "${PKG_NAME}" "${_PKG_FILE}"
}

function package_bff
{
    package_init
    populate "${PKG_PREFIX_DIR}" ""

    local _PKG_LAYOUT=${PKG_PACKAGE_ROOT}/$(echo ${PKG_NAME} | sed 's|\.|/|')
    local _PKG_FILE=${PKG_PACKAGE_ROOT}/${PKG_NAME}-${PKG_VERSION}-${PKG_RELEASE}.${BUILD_OS_ARCH}.bff
    local _CONTROL_FILE="${_PKG_LAYOUT}/control.in"

    mkdir -p ${_PKG_LAYOUT}
    exit_on_error $?

    rsync -a --exclude .svn ${PKG_DIR}/ ${_PKG_LAYOUT}/
    exit_on_error $?
    
    mv ${PKG_POPULATE_ROOT}/ ${_PKG_LAYOUT}/root
    exit_on_error $?
    
    mkdir -p ${_PKG_LAYOUT}/root/usr/lpp/likewise
    exit_on_error $?

    mv ${_PKG_LAYOUT}/root/${PKG_PREFIX_DIR} ${_PKG_LAYOUT}/root/usr/lpp/likewise/opt-likewise
    exit_on_error $?
    
    ln -s /usr/lpp/likewise/opt-likewise ${_PKG_LAYOUT}/root/${PKG_PREFIX_DIR}
    exit_on_error $?
    
    sed \
        -e "s|__ARCH__|${BUILD_OS_ARCH}|g" \
        -e "s|__PKG_NAME__|${PKG_NAME}|g" \
        -e "s|__PKG_VERSION__|${PKG_VERSION}|g" \
        -e "s|__PKG_RELEASE__|${PKG_FULL_RELEASE}|g" \
        -e "s|__BASEDIR__|${PKG_PREFIX_DIR}|g" \
        ${_CONTROL_FILE} > ${_PKG_LAYOUT}/control
    exit_on_error $?

    pushd $(dirname ${_PKG_LAYOUT})
    PATH=${BUILD_ROOT}/src/linux/build/lib/lppbuild:$PATH lppbuild
    exit_on_error $?
    mv "$(echo ${PKG_NAME} | sed 's/\..*$//').bff" "${_PKG_FILE}"
    exit_on_error $?
    popd
    
    copy_dist "${PKG_NAME}" "${_PKG_FILE}"
}


function pkg_fixup_prototype_standard_dirs
{
    check_arg source "$1"
    check_arg target "$2"

    # Make sure that we do not attempt to override any perms
    # on standard directories.
    perl -n -e '
foreach (<STDIN>) {
        foreach $k qw(
        /usr
        /usr/bin
        /usr/lib
        /usr/lib/64
        /usr/lib/amd64
        /usr/lib/sparcv9
        /usr/lib/security
        /usr/lib/security/64
        /usr/lib/security/amd64
        /usr/lib/security/sparcv9
        /etc
        /etc/init\\.d
        /etc/rc[0-9Ss]\\.d
        /etc/security
        \\/
        /var
        /var/cache
        /var/lib
        /var/log
        )
        {
                    last if (s/^(d none $k) .*/$1 ? ? ?/);
        }
        print $_;
}' \
    < "$1" > "$2"

    local dir="${BUILD_PREFIX}"

    while [ "${dir}" != "/" ]
    do
	grep -v "^d none ${dir}" < "${2}" > "${2}.out"
	mv "${2}.out" "${2}"
	dir="`dirname ${dir}`"
    done

    exit_on_error $?
}

function pkg_fixup_prototype_user_group
{
    check_arg source "$1"
    check_arg target "$2"

    #
    # This function removes the current " user group" from the ends
    # of lines in pkg prototype file.
    #

    local _UID=`/usr/xpg4/bin/id -u`
    local _GID=`/usr/xpg4/bin/id -g`

    check_arg _UID "$_UID"
    check_arg _GID "$_GID"

    local _USER=`getent passwd $_UID | cut -d: -f1`
    local _GROUP=`getent group $_GID | cut -d: -f1`

    check_arg _USER "$_USER"
    check_arg _GROUP "$_GROUP"

    #
    # Remove user/group to pick up default from !default directive.
    #

    sed -e "s/ ${_USER} ${_GROUP}$//" < "$1" > "$2"
    exit_on_error $?
}

function pkg_create_prototype
{
    check_arg target "$1"
    check_arg PKG_POPULATE_ROOT "${PKG_POPULATE_ROOT}"

    # Add files
    # Grab only non-directory files, as we should have the dirs
    # from .master

    # Enumerate all files
    pkgproto ${PKG_POPULATE_ROOT}=/ | sed "s: ${BUILD_PREFIX}/: :" > "$1.tmp.1"

    # Make sure that we do not attempt to override any perms
    # on standard directories.
    pkg_fixup_prototype_standard_dirs "$1.tmp.1" "$1.tmp.2"
    exit_on_error $?

    # Fix up permissions
    pkg_fixup_prototype_user_group "$1.tmp.2" "$1"
    exit_on_error $?
}

function pkg_create_package
{
    check_arg CONTROL_DIR "${CONTROL_DIR}"
    check_arg OUT_DIR "${OUT_DIR}"
    check_arg OUT_FILE "${OUT_FILE}"
    check_arg PKG_NAME "${PKG_NAME}"

    # Create the package layout
    ( set -x && cd ${CONTROL_DIR} && pkgmk -o -d ${OUT_DIR} -b . -f prototype ${PKG_NAME} )
    exit_on_error $?

    # Create the package from the layout
    ( set -x && pkgtrans ${OUT_DIR} ${OUT_FILE} ${PKG_NAME} )
    exit_on_error $?
}

function package_pkg
{
    package_init
    populate "${PKG_PREFIX_DIR}" ""

    local CONTROL_DIR=${PKG_PACKAGE_ROOT}/control
    local PROTO_DIR=${PKG_PACKAGE_ROOT}/proto
    local OUT_DIR=${PKG_PACKAGE_ROOT}/out
    local OUT_FILE=${PKG_PACKAGE_ROOT}/${PKG_NAME}-${PKG_VERSION}.${PKG_RELEASE}-${BUILD_OS_ARCH}.pkg

    mkdir -p ${CONTROL_DIR}
    exit_on_error $?

    mkdir -p ${OUT_DIR}
    exit_on_error $?

    #
    # Need: prototype.master pkginfo.master
    #

    rsync -a --exclude .svn ${PKG_DIR}/ ${CONTROL_DIR}/
    exit_on_error $?

    #
    # Prepare pkginfo.master
    #

    sed \
        -e "s|__PKG__|${PKG_NAME}|g" \
        -e "s|__ARCH__|${BUILD_OS_ARCH}|g" \
        -e "s|__VERSION__|${PKG_VERSION}.${PKG_FULL_RELEASE}|g" \
        -e "s|__BASEDIR__|${PKG_PREFIX_DIR}|g" \
        ${CONTROL_DIR}/pkginfo.master > ${CONTROL_DIR}/pkginfo
    exit_on_error $?

    #
    # Prepare prototype.master
    #

    cp ${CONTROL_DIR}/prototype.master ${CONTROL_DIR}/prototype
    exit_on_error $?

    #
    # Create prototype.files for inclusion in prototype
    #

    pkg_create_prototype "${CONTROL_DIR}/prototype.files"
    exit_on_error $?

    #
    # Package
    #

    pkg_create_package
    exit_on_error $?

    copy_dist ${PKG_NAME} ${OUT_FILE}
    exit_on_error $?
}

function freebsd_packing_list
{
    (
        source "${PKG_DIR}/config"
        
        echo "@name ${PKG_NAME}-${PKG_VERSION}.${PKG_RELEASE}"

        for dep in $DEPENDS
        do
          echo "@pkgdep ${dep}-${PKG_VERSION}.${PKG_RELEASE}"
        done

        echo "@cwd /"
        echo "@srcdir ${PKG_PACKAGE_ROOT}/root"
        echo "@owner root"
        echo "@group wheel"
        cd "${PKG_PACKAGE_ROOT}/root" && \
        (
            for file in `find .`
            do
                if ! test -d "$file"
                then
                    echo "$file" | sed 's:^\./::'
                fi
            done
        )
    )
}

function freebsd_description
{
    (
        source "${PKG_DIR}/config"
        if [ -n "$DESCRIPTION" ]; then
            echo "$DESCRIPTION"
        else
            echo "$PKG_DESC"
        fi
    )
}

function freebsd_long_description
{
    (
        source "${PKG_DIR}/config"
        if [ -n "$LONG_DESCRIPTION" ]; then
            echo "$LONG_DESCRIPTION"
        elif [ -n "$DESCRIPTION" ]; then
            echo "$DESCRIPTION"
        else
            echo "$PKG_DESC"
        fi
    )
}

function freebsd_scripts
{
    local preinstall=${PKG_DIR}/preinstall
    local postinstall=${PKG_DIR}/postinstall
    local preuninstall=${PKG_DIR}/preuninstall
    local postuninstall=${PKG_DIR}/postuninstall

    [ -f $preinstall ] && echo "-i $preinstall"
    [ -f $postinstall ] && echo "-I $postinstall"
    [ -f $preuninstall ] && echo "-k $preuninstall"
    [ -f $postuninstall ] && echo "-K $postuninstall"
}

function package_freebsd
{
    package_init
    populate "${PKG_PREFIX_DIR}" ""

    local OUT_FILE=${PKG_PACKAGE_ROOT}/${PKG_NAME}-${PKG_VERSION}.${PKG_RELEASE}-${BUILD_OS_ARCH}.tbz

    mkdir -p ${PKG_PACKAGE_ROOT}
    exit_on_error $?

    ln -s ${PKG_POPULATE_ROOT} ${PKG_PACKAGE_ROOT}/root
    exit_on_error $?

    echo "Creating $OUT_FILE"

    freebsd_packing_list | pkg_create \
        -f - \
        -o "likewise/${PKG_NAME}" \
        -c "-`freebsd_description`" \
        -d "-`freebsd_long_description`" \
        `freebsd_scripts` \
        "$OUT_FILE"

    copy_dist ${PKG_NAME} ${OUT_FILE}
    exit_on_error $?
}


function create_archive
{
    local _targetFile="$1"
    local _baseDir="$2"
    local _fileSpec="$3"

    (cd "${_baseDir}" && compress_archive "${_fileSpec}" "${_targetFile}" )
    exit_on_error $?
}

function package_source
{
    package_init

    source ${PKG_VARS_FILE}

    local _pkg_dir=${PKG_NAME}-${PKG_VERSION}.${PKG_FULL_RELEASE}

    local OUT_FILE=${PKG_POPULATE_ROOT}/${_pkg_dir}"`get_archive_suffix`"

    mkdir -p ${PKG_POPULATE_ROOT}/${_pkg_dir}
    exit_on_error $?

    for p in ${PKG_COMPONENTS};
    do
	source ${BUILD_ROOT}/src/linux/build/components/${p}.comp
	echo "Copying source for component \"${p}\"..."
	rsync -a --exclude=.svn ${COMP_SOURCES} ${PKG_POPULATE_ROOT}/${_pkg_dir}/
    done

    echo "Creating $OUT_FILE"

    create_archive "${OUT_FILE}" "${PKG_POPULATE_ROOT}" "${_pkg_dir}"

    copy_dist ${PKG_NAME} ${OUT_FILE}
    exit_on_error $?
}

function mac_make_package
{
    check_arg inputPmprojFile "$1"
    check_arg outputPkgFile "$2"
 
    "${PMAKER}" -build -p "$2" -b /tmp -f . -proj "$1"
     if [ $? -ne 0 ]; then
         echo "Error calling PackageMaker (please check that you are using version 2.1.1)"
         echo "For Mac systems with OSX > 10.4, try adding /Developer/Applications/Utilities/PackageMaker-2.1.1/PackageMaker.app to your system to fix."
         exit $?
     fi
}

function mac_combine_binaries
{
    (
        cd "${PKG_POPULATE_ROOT}"
        IFS=$'\n'
        for f in `find .`
        do
            if [ ! -L "$f" ]; then
                case "`file "$f"`" in
                *"Mach-O"*)
                    echo "Merging binary: $f"
                    f2="${PKG_POPULATE_ROOT}-compat/${f}"
                    lipo -create -output "${f}.univ" "$f" "$f2"
                    if [ $? -ne 0 ]; then
                        if [ -n "$2" ]; then
                            echo "Lipo error, warning:"
                            warn "$2"
                            echo "Skipping merge"
                        else
                            echo "Lipo error, skipping merge"
                        fi
                    else
                        echo "Merge completed"
                        rm -f "${f}"
                        mv "${f}.univ" "${f}"
                    fi
                    ;;
                    esac
            fi
        done
    )

    exit_on_error "$?"
}

function package_mac
{
    package_init
    
    PKG_COMPAT_SEPARATE_POPULATE_ROOT="1"

    populate "${PKG_PREFIX_DIR}" ""

    exit_on_error "$?"

    local ARCH_RENAME="$BUILD_OS_ARCH"

    case "`uname -r 2>/dev/null`" in
	10.*)
	    mac_combine_binaries
            local ARCH_RENAME="OSX10.6-universal"
	    ;;
    esac
    
    local PMAKER=/Developer/Applications/Utilities/PackageMaker-2.1.1/PackageMaker.app/Contents/MacOS/PackageMaker
    if [ ! -x "${PMAKER}" ]; then
        local PMAKER=/Developer/Applications/Utilities/PackageMaker.app/Contents/MacOS/PackageMaker
        if [ ! -x "${PMAKER}" ]; then
            warn "Could not find ${PMAKER}."
            exit 1
        fi
    fi

    local CONTROL_DIR="${PKG_PACKAGE_ROOT}/control"
    local PROTO_DIR="${PKG_PACKAGE_ROOT}/proto"

    local OUT_DIR="${PKG_PACKAGE_ROOT}/out"
    local _OUT_FS="${OUT_DIR}/${PKG_NAME}-${PKG_VERSION}.${PKG_FULL_RELEASE}.${ARCH_RENAME}.pkg"
    local _OUT_FILE="${OUT_DIR}/${PKG_NAME}-${PKG_VERSION}.${PKG_FULL_RELEASE}.${ARCH_RENAME}.dmg"

    local PROJ_DIR="${PKG_PACKAGE_ROOT}/project"
    local _PROJ_FILE="${PROJ_DIR}/mac_pkg_description.pmproj"

    mkdir -p "${CONTROL_DIR}"
    exit_on_error $?

    mkdir -p "${PROTO_DIR}"
    exit_on_error $?

    mkdir -p "${OUT_DIR}"
    exit_on_error $?

    cp -fp "${BUILD_ROOT}/src/linux/build/products/lwe/macpckgr/Resources/English.lproj/background.gif" "${CONTROL_DIR}/rgb_hybrid_mac_install.gif"
    rsync -a --exclude=.svn "${BUILD_ROOT}/src/linux/licenses/" "${CONTROL_DIR}/licences/"

    #
    # Copy package files
    #

    rsync -a --exclude=.svn --exclude '*.vars' --exclude '*.func' --exclude 'project' ${PKG_DIR}/ ${CONTROL_DIR}/
    exit_on_error $?

    rsync -a --exclude=.svn ${PKG_DIR}/project/ ${PROJ_DIR}/
    exit_on_error $?

    #
    # Package
    #

    pushd "${PROTO_DIR}"
    exit_on_error $?

    if [ -f "${_PROJ_FILE}" ]; then
	sed -e "s/@LIKEWISE_VERSION@/${MAIN_VERSION}/g" \
	    -e "s/@LIKEWISE_PKG_NAME@/${PKG_NAME}/g" \
	    -e "s/@LIKEWISE_PKG_DESC@/${PKG_DESC}/g" \
	    < ${_PROJ_FILE} \
	    > ${PROJ_DIR}/proj.pmproj
        mac_make_package "${PROJ_DIR}/proj.pmproj" "${_OUT_FS}"
    else
        warn "${_PROJ_FILE} does not exist!"
        exit 1
    fi

    popd
    exit_on_error $?

    #
    # Copy
    #

    copy_dist "${PKG_NAME}" "${_OUT_FS}"
}

function package_init
{
    echo "Cleaning ${PKG_BUILD_ROOT}"
    recreate_dir "${PKG_BUILD_ROOT}"
}

function populate
{
    PKG_POPULATE_PREFIX_DIR="${PKG_POPULATE_ROOT}"
    PKG_POPULATE_ROOT_DIR="${PKG_POPULATE_ROOT}"

    if [ -n "$1" ]; then
        PKG_POPULATE_PREFIX_DIR="${PKG_POPULATE_PREFIX_DIR}/$1"
    fi

    if [ -n "$2" ]; then
        PKG_POPULATE_ROOT_DIR="${PKG_POPULATE_ROOT_DIR}/$1"
    fi

    mkdir -p "${PKG_POPULATE_ROOT}"
    exit_on_error $?

    op_invoke populate

    if [ -d "${PKG_DEBUG_FILES_ROOT}" ]; then
        (cd "${PKG_DEBUG_FILES_ROOT}" && compress_archive ./ "${PKG_DEBUG_ROOT}/${PKG_DEBUG_ARCHIVE}" )
        exit_on_error $?

        mkdir -p "${PKG_DEBUG_DIST_DIR}"
        exit_on_error $?

        echo "Copying debug archive to dist..."
        cp -p "${PKG_DEBUG_ROOT}/${PKG_DEBUG_ARCHIVE}" "${PKG_DEBUG_DIST_DIR}/."
        exit_on_error $?
    fi

    if [ -z "${OPT_NO_COMPAT}" -a -n "${PKG_NEED_COMPAT}" -a -z "${PKG_IS_COMPAT}" -a "${PKG_COMPAT_DISPOSITION}" = "comp" ]; then
        echo "Performing compat population"
	if [ -n "$PKG_COMPAT_SEPARATE_POPULATE_ROOT" ]
	then
	    PKG_POPULATE_PREFIX_DIR="${PKG_POPULATE_ROOT}-compat"
            PKG_POPULATE_ROOT_DIR="${PKG_POPULATE_ROOT}-compat"
	    
	    if [ -n "$1" ]; then
		PKG_POPULATE_PREFIX_DIR="${PKG_POPULATE_PREFIX_DIR}/$1"
	    fi
	    
	    if [ -n "$2" ]; then
		PKG_POPULATE_ROOT_DIR="${PKG_POPULATE_ROOT_DIR}/$1"
	    fi
	fi
        ( PKG_IS_COMPAT=1 && setup_package_vars && op_invoke populate )
        exit_on_error $?
    fi

    if [ -z "${OPT_NO_COMPAT}" -a -n "${PKG_NEED_FOREIGN}" -a -z "${PKG_IS_FOREIGN}" ]; then
        echo "Performing foreign population"        
        ( PKG_IS_FOREIGN=1 && setup_package_vars && op_invoke populate )
        exit_on_error $?
    fi
}

function do_package
{
    PKG_IS_RECURSED="$1"

    #
    # Set up the most basic variables needed to set up everything else.
    #

    PKG_DIR="${PACKAGES_DIR}/${PKG_ALIAS}/${PKG_TYPE}"
    PKG_VARS_FILE="${PKG_DIR}/${PKG_ALIAS}.func"
    PKG_FUNC_FILE="${PKG_DIR}/${PKG_ALIAS}.func"
    PKG_IS_COMPAT=""
    if [ -n "${PKG_IS_RECURSED}" -o -n "${OPT_COMPAT}" ]; then
        PKG_IS_COMPAT=1
    fi

    #
    # Check that package is defined properly.
    #

    if [ ! -f "${PKG_VARS_FILE}" ]; then
        if [ -f "${PKG_DIR}/../${PKG_ALIAS}.func" ]; then
            PKG_VARS_FILE="${PKG_DIR}/../${PKG_ALIAS}.func"
            PKG_FUNC_FILE="${PKG_DIR}/../${PKG_ALIAS}.func"
        else
            echo "Package \"${PKG_ALIAS}\" does not exist!"
            exit 1
        fi
    fi

    #
    # Indicate what component we are doing.
    #

    local compatSuffix=""
    if [ -n "${COMP_IS_COMPAT}" ]; then
        compatSuffix=" (compat)"
    fi
    echo "Package: ${PKG_ALIAS}${compatSuffix}"

    #
    # Setup the per-component variables, reading config as needed.
    #

    setup_package_vars

    #
    # Check for validity of comapt/nocompat
    #

    if [[ -n "${PKG_IS_COMPAT}" && -z "${PKG_NEED_COMPAT}" ]]; then
        echo "32-bit compatibility build is invalid for \"${PKG_ALIAS}\""
    fi

    if [ -z "${PKG_IS_RECURSED}" ]; then
        recreate_dir "${PKG_DIST_DIR}"
    fi

    #
    # Now do whichever steps we need.
    #

    case "${PKG_TYPE}" in
        rpm)
            package_rpm
            ;;
        deb)
            package_deb
            ;;
        pkg)
            package_pkg
            ;;
        mac)
            package_mac
            ;;
        depot)
            package_depot
            ;;
        bff)
            package_bff
            ;;
        freebsd)
            package_freebsd
            ;;
	source)
	    package_source
	    return 0
	    ;;
        *)
            warn "Unsupported package type: ${PKG_TYPE}"
            exit 1
            :;
    esac

    #
    # Do compat as needed:
    #
    # - compat allowed
    # - not doing compat
    # - need compat
    # - pkg-level compat
    #

    if [[ -z "${OPT_NO_COMPAT}" && -z "${PKG_IS_COMPAT}" && -n "${PKG_NEED_COMPAT}" && "${PKG_COMPAT_DISPOSITION}" = "pkg" ]]; then
        ( time_command "${PKG_ALIAS} (compat)" do_package 1 )
        exit_on_error $?
    fi

    return 0
}

function setup_package_vars
{
    #
    # Set archiving environment (including zip suffix)
    #

    #_setup_archive_vars
    #exit_on_error $?

    #
    # Read component variables
    #

    PKG_VERSION=""
    PKG_RELEASE=""
    PKG_NEED_COMPAT=""
    PKG_NEED_FOREIGN=""
    PKG_COMPAT_DISPOSITION=""

    local -x _FILE="${PKG_VARS_FILE}"
    local -x PKG_ALIAS="${PKG_ALIAS}"

    local _result
    _result=`PKG_TYPE="${PKG_TYPE}" invoke_helper _invoke_vars "$@"`
    exit_on_error $?

    # echo "results=[${_result}]"
    PKG_VERSION=`echo "${_result}" | sed -e /^PKG_VERSION=/!d -e s/^PKG_VERSION=// | tail -1`
    PKG_DESC=`echo "${_result}" | sed -e /^PKG_DESC=/!d -e s/^PKG_DESC=// | tail -1`
    PKG_RELEASE=`echo "${_result}" | sed -e /^PKG_RELEASE=/!d -e s/^PKG_RELEASE=// | tail -1`
    PKG_NEED_COMPAT=`echo "${_result}" | sed -e /^PKG_NEED_COMPAT=/!d -e s/^PKG_NEED_COMPAT=// | tail -1`
    PKG_NEED_FOREIGN=`echo "${_result}" | sed -e /^PKG_NEED_FOREIGN=/!d -e s/^PKG_NEED_FOREIGN=// | tail -1`
    PKG_COMPAT_IS_FULL=""

    PKG_NAME="`package_native_name "${PKG_ALIAS}"`"
      
    echo "PKG_NAME=${PKG_NAME}"

    #
    # Fix up whether we really need compat based on platform
    #

    case "${BUILD_OS_TYPE}-${BUILD_OS_ARCH}" in
        linux-x86_64|hpux-*|solaris-sparc)
            : # Yes
            ;;
        solaris-i386)
            [ "`uname -r`" = "5.10" ] || PKG_NEED_COMPAT=""
            ;;
	darwin-x86_64)
	    PKG_NEED_COMPAT="1"
	    PKG_COMPAT_IS_FULL="1"
	    ;;
        *)
            PKG_NEED_COMPAT=""
            ;;
    esac
    
    if [ -n "${PKG_NEED_FOREIGN}" ]; then
        case "${BUILD_OS_TYPE}-${BUILD_OS_ARCH}" in
            hpux-ia64)
                PKG_NEED_FOREIGN="hppa20"
                ;;
            solaris-i386)
                if [ "`uname -r`" = "5.10" ]; then
                    PKG_NEED_FOREIGN=""
                else
                    PKG_NEED_FOREIGN="i386"
                fi
                ;;
            *)
                PKG_NEED_FOREIGN=""
                ;;
        esac
    fi

    #
    # Set default compatibility disposition 
    #

    if [ -z "${PKG_COMPAT_DISPOSITION}" ]; then
        case "${PKG_TYPE}" in
            rpm)
                PKG_COMPAT_DISPOSITION="pkg"
                ;;
            *)
                PKG_COMPAT_DISPOSITION="comp"
                ;;
        esac
    fi
           
    #
    # Figure out version/release information
    #

    PKG_USING_DEFAULT_VERSION=""
    if [ -n "${PKG_VERSION}" ]; then
        if [ -z "${PKG_RELEASE}" ]; then
            echo "PKG_VERSION specified, but missing PKG_RELEASE variable."
            exit 1
        fi
    else
        if [ -n "${PKG_RELEASE}" ]; then
            echo "PKG_RELEASE specified, but missing PKG_VERSION variable."
            exit 1
        fi
        PKG_USING_DEFAULT_VERSION=1
        PKG_VERSION="${MAIN_VERSION}"
        PKG_RELEASE="${MAIN_RELEASE}"
    fi

    PKG_FULL_RELEASE="${PKG_RELEASE}.${SVN_REVISION}"
    if [ -n "${OFFICIAL_BUILD_NUMBER}" ]; then
        PKG_FULL_RELEASE="${PKG_FULL_RELEASE}.${OFFICIAL_BUILD_NUMBER}"
    fi

    #
    # Compute compat parts
    #

    local _32bit=""
    local _32bitDirSuffix=""
    if [ -n "${PKG_IS_COMPAT}" ]; then
        _32bit="-compat"
        _32bitDirSuffix="-compat"
    fi

    local _archiveSuffix=`get_archive_suffix`
    PKG_DEBUG_ARCHIVE="${PKG_NAME}-${PKG_VERSION}.${PKG_FULL_RELEASE}-${BUILD_OS_ARCH}${_32bit}-debug${_archiveSuffix}"

    #
    # Compute directories
    #

    PKG_PREFIX_DIR="${MAIN_PREFIX_DIR}"

    PKG_BUILD_ROOT="${PKG_META_ROOT}/${PKG_ALIAS}/${PKG_TYPE}"
    PKG_POPULATE_ROOT="${PKG_BUILD_ROOT}/populate${_32bitDirSuffix}"
    PKG_DEBUG_ROOT="${PKG_BUILD_ROOT}/debug${_32bitDirSuffix}"
    PKG_PACKAGE_ROOT="${PKG_BUILD_ROOT}/package${_32bitDirSuffix}"
    PKG_EXPAND_ROOT="${PKG_BUILD_ROOT}/expand${_32bitDirSuffix}"

    PKG_DEBUG_FILES_ROOT="${PKG_DEBUG_ROOT}/files"

    PKG_DIST_DIR="${PKG_DIST_ROOT}/${PKG_ALIAS}/${PKG_TYPE}"
    PKG_DEBUG_DIST_DIR="${PKG_DIST_DIR}/debug"

    ### XXX - keep these in-sync w/mkcomp

    if [ -n "${PKG_IS_FOREIGN}" ]; then
        if [ "${BUILD_OS_TYPE}" = "solaris" ]; then
            _32bitDirSuffix="-compat"
        fi
        COMP_STAGING_PREFIX="${BUILD_META_ROOT}/${BUILD_OS_TYPE}/${PKG_NEED_FOREIGN}/components"
    else
        COMP_STAGING_PREFIX="${BUILD_META_OS_ROOT}/components"
    fi
    COMP_STAGING_SUFFIX="staging${_32bitDirSuffix}"

    return 0
}

function op_invoke
{
    local -x _OP="$1"
    shift

    local -x _FILE="${PKG_FUNC_FILE}"
    local -x _DIR="${PKG_DIR}"

    local -x PKG_TYPE="${PKG_TYPE}"
    local -x PKG_ALIAS="${PKG_ALIAS}"
    local -x PKG_NAME="${PKG_NAME}"
    local -x PKG_VERSION="${PKG_VERSION}"
    local -x PKG_RELEASE="${PKG_RELEASE}"
    local -x PKG_COMPAT_DISPOSITION="${PKG_COMPAT_DISPOSITION}"
    local -x PREFIX_DIR="${PKG_PREFIX_DIR}"
    local -x PKG_IS_COMPAT="${PKG_IS_COMPAT}"
    if [ -z "${PKG_COMPAT_IS_FULL}" ]
    then
	local -x IS_COMPAT="${PKG_IS_COMPAT}"
    fi
    local -x IS_FOREIGN="${PKG_IS_FOREIGN}"
    local -x POPULATE_ROOT="${PKG_POPULATE_ROOT}"
    local -x POPULATE_PREFIX_DIR="${PKG_POPULATE_PREFIX_DIR}"
    local -x POPULATE_ROOT_DIR="${PKG_POPULATE_ROOT_DIR}"
    local -x POPULATE_DEBUG_DIR="${PKG_DEBUG_FILES_ROOT}"
    local -x PKG_DIST_ROOT="${PKG_DIST_ROOT}"
    local -x PKG_DIST_DIR="${PKG_DIST_DIR}"
    local -x COMP_STAGING_PREFIX="${COMP_STAGING_PREFIX}"
    local -x COMP_STAGING_SUFFIX="${COMP_STAGING_SUFFIX}"
    local -x PACKAGES_DIR="${PACKAGES_DIR}"
    local -x OLDLIBC=0
    if check_is_rhel_21; then
        OLDLIBC=1
    fi

    invoke_helper _invoke_op "$@"
    exit_on_error $?

    return 0
}

function invoke_helper
{
    bash -e <<EOF
source "${PACKAGES_DIR}/../common.sh"
source "${PACKAGES_DIR}/../lib/mkpkg-helper.sh"
#exit_on_error \$?
"$@"
exit \$?
EOF
    return $?
}

function usage
{
    local pkg_type_all=`pkgtype_get_all_pkgtypes`
    echo "usage: `basename $1` [options] <packageAlias> [<packageAlias> ...]"
    echo ""
    echo "  description:"
    echo ""
    echo "    Builds one or more packages in the build system."
    echo ""
    echo "  options:"
    echo ""
    echo "    --type <TYPE>     Type of package to build: ${pkg_type_all}"
    echo ""
    echo "    --nocompat        Skip 32-bit compat build."
    echo ""
    echo "    --compat          Only do 32-bit compat build."
    echo ""
    echo "  symbol options:"
    echo ""
    echo "    --debug           Force build with debug information."
    echo "    --nodebug         Force build without debug information."
    echo "    --profiling         Force build with profiling information."
    echo "    --noprofiling       Force build without profiling information."
    echo ""
    echo "  available package aliases:"
    echo ""
    local type
    local package
    local packages_list
    local type_list
    local pkg_type_current_all=`pkgtype_get_current_os_pkgtype_allow_list`
    packages_list=`ls -1 ${PACKAGES_DIR} 2> /dev/null`
    for package in ${packages_list}; do
        type_list=""
        for type in ${pkg_type_current_all}; do
            if [ -d "${PACKAGES_DIR}/${package}/${type}" ]; then
                if [ -z "${type_list}" ]; then
                    type_list="${type}"
                else
                    type_list="${type_list}, ${type}"
                fi
            fi
        done
        if [ -n "${type_list}" ]; then
            echo "    ${package} (${type_list})"
        fi
    done
}

function usage_bad_multi
{
    echo "Cannot specify $1 more than once."
    exit 1
}

##
## Main driver code
##

function main
{
    if [ -z "${BUILD_ROOT}" ]; then
        echo "You need to source buildenv first"
        exit 1
    fi

    . ${BUILD_ROOT}/src/linux/build/common.sh
    exit_on_error $? "Perhaps the BUILD_ROOT environment variable is incorrect."

    . ${BUILD_ROOT}/src/linux/build/version.sh
    exit_on_error $?

    set_ctrlc_trap

    _RPM_BUILD_OS_ARCH=${BUILD_OS_ARCH}
    if [ "${_RPM_BUILD_OS_ARCH}" = "powerpc" ]; then
        _RPM_BUILD_OS_ARCH="ppc"
    fi

    PACKAGES_DIR="${BUILD_ROOT}/src/linux/build/packages"
    PKG_META_ROOT="${BUILD_META_OS_ROOT}/packages"
    PKG_DIST_ROOT="${BUILD_DIST_OS_ROOT}/packages"

    case "${BUILD_OS_TYPE}" in
        linux)
            if [ -f /etc/debian_version ]; then
                DEFAULT_PKG_TYPE="deb"
            else
                DEFAULT_PKG_TYPE=rpm
            fi
            ;;
        solaris)
            DEFAULT_PKG_TYPE=pkg
            ;;
        aix)
            DEFAULT_PKG_TYPE=bff
            ;;
        darwin)
            DEFAULT_PKG_TYPE=mac
            ;;
        hpux)
            DEFAULT_PKG_TYPE=depot
            ;;
        freebsd)
            DEFAULT_PKG_TYPE=freebsd
            ;;
        *)
            warn "Unsupported platform: ${BUILD_OS_TYPE}"
            exit 1
            ;;
    esac

    PKG_TYPE=""
    PKG_TYPE_LIST=""
    OPT_NO_COMPAT=""
    OPT_COMPAT=""
    parseOptDone=""

    while [[ -z "${parseOptDone}" ]]; do
        case "$1" in
            --help)
                usage "$0"
                exit 0
                ;;
            --nocompat)
                OPT_NO_COMPAT=1
                shift
                ;;
            --compat)
                OPT_COMPAT=1
                shift
                ;;
            --type)
                PKG_TYPE="$2"
                if [ -z "${PKG_TYPE}" ]; then
                    echo "Missing argument to $1 option."
                    exit 1
                fi
                PKG_TYPE_LIST="${PKG_TYPE_LIST} ${PKG_TYPE}"
                shift 2
                ;;
            --debug)
                export BUILD_DEBUG=1
                shift
                ;;
            --nodebug)
                unset BUILD_DEBUG
                shift
                ;;
            --profiling)
                export BUILD_PROFILING=1
                shift
                ;;
            --noprofiling)
                unset BUILD_PROFILING
                shift
                ;;
            *)
                parseOptDone=1
                ;;
        esac
    done

    if [ -z "${PKG_TYPE_LIST}" ]; then
        PKG_TYPE_LIST="${DEFAULT_PKG_TYPE}"
    fi

    #
    # Get packages
    #

    local _pkgs="$@"
    local -i _count=0
    for PKG_ALIAS in ${_pkgs} ; do
        _count=${_count}+1

        #
        # Check package name
        #

        for PKG_TYPE in ${PKG_TYPE_LIST} ; do

            if [ ! -d "${PACKAGES_DIR}/${PKG_ALIAS}" ]; then
                echo "Invalid package: \"${PKG_ALIAS}\""
                exit 1
            fi

            if [ ! -d "${PACKAGES_DIR}/${PKG_ALIAS}/${PKG_TYPE}" ]; then
                echo "Invalid package type \"${PKG_TYPE}\" for package \"${PKG_ALIAS}\""
                exit 1
            fi
        done
    done

    if [ ${_count} -le 0 ]; then
        echo "Missing package argument."
        usage "$0"
        exit 1
    fi

    #
    # Build packages
    #

    for PKG_ALIAS in ${_pkgs} ; do
        for PKG_TYPE in ${PKG_TYPE_LIST} ; do
            local compatSuffix=""
            if [ -n "${OPT_COMPAT}" ]; then
                compatSuffix=" (compat)"
            fi
            time_command "${PKG_ALIAS}${compatSuffix}" do_package
            exit_on_error $?
        done
    done
}

main "$@"
exit 0
